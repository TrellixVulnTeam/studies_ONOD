
# 1. Исследуем замыкание в Питоне
def functionA(x):                                   # обрамляющая функция
    v = 'variable v'                                # объявляем переменную замыкания и инициализируем
    def functionB():
        print(v)                                    # выводим переменную замыкания для диагностики
    v = 'w'                                         # изменение значения переменной замыкания v отразится на
    return functionB

f = functionA(None)
#print(f.v)                                          # пытаемся напрямую обратиться к переменной замыкания, что некорректно
f()                                                 # выводит w, поскольку переменная замыкания это тоже объект, и его значение поменялось перед выводом

# 2. Посмотрим как поведёт себя объявление нелокальной функции
def functionD():
    F = None
    def functionC():
        gg = 'variable'
        nonlocal F
        def F():
            print('function F')
    functionC()
    if F:
        F()
functionD() # объявленная как nonlocal, функция F успешно создаётся и вызывается из обрамляющей функции
